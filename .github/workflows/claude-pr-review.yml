name: Claude PR Review

on:
  pull_request:
    types: [opened, reopened, synchronize]
    paths-ignore:
      - "**.md"             # ignore documentation
      - "**.MD"
      - "**.txt"
      - "**.json"           # skip metadata/config updates if you want
      - "**/docs/**"
      - "**/CHANGELOG*"
      - "**/LICENSE*"
      - "**/README*"
      - "**/test/**"        # optionally skip pure test-only changes
      - "**/tests/**"
      - "**/fixtures/**"


permissions:
  contents: read
  pull-requests: write

jobs:
  claude-review:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get diff against base
        id: get_diff
        run: |
          git fetch origin ${{ github.base_ref }} --depth=1
          git diff origin/${{ github.base_ref }}...HEAD > pr.diff

          # truncate for safety
          MAX_SIZE=100000
          if [ $(wc -c < pr.diff) -gt $MAX_SIZE ]; then
            echo "‚ö†Ô∏è Diff too large, truncating..."
            head -c $MAX_SIZE pr.diff > pr.truncated.diff
            mv pr.truncated.diff pr.diff
          fi

          # expose diff as output
          echo "diff<<EOF" >> $GITHUB_OUTPUT
          cat pr.diff >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Cache Claude CLI
        uses: actions/cache@v4
        with:
          path: |
            ~/.claude
            ~/.local/bin/claude
          key: ${{ runner.os }}-claude-cli-v1

      - name: Run Claude review (base action)
        id: claude
        uses: anthropics/claude-code-base-action@beta
        with:
          # this one ALWAYS runs the prompt ‚Äî no trigger needed
          prompt: |
            <!-- claude-code-review -->
            <!-- claude-code-review -->
            You are a **senior web engineer** reviewing a pull request written primarily in **React, TypeScript, and Next.js**.

            ## üéØ Goal
            Provide a thoughtful, high-value review focused on **clarity, maintainability, performance, accessibility, and reliability**.
            Think like an experienced teammate ‚Äî pragmatic, context-aware, and focused on meaningful improvements rather than rigid enforcement.

            ## üß© How to Review
            1. **Understand the intent** ‚Äì briefly summarize what the change appears to do.
            2. **Evaluate quality** ‚Äì identify issues that could impact performance, scalability, or readability.
            3. **Use judgment** ‚Äì apply best practices, but balance them with the context of the codebase. Avoid ‚Äúblanket‚Äù rules.
            4. **Educate** ‚Äì explain *why* something might be problematic and propose actionable, concise improvements.
            5. **Prioritize** ‚Äì highlight the top 3‚Äì5 insights that would create the biggest impact.

            ---

            ## ‚öôÔ∏è State Management & Data Flow
            - Encourage colocating state at the lowest reasonable level; avoid over-lifting state unless justified by shared logic.
            - Avoid direct mutations ‚Äî prefer immutable patterns.
            - If state or props are passed too deeply, suggest Context or custom hooks when it clearly improves clarity.
            - Prefer data-fetching libraries (React Query, SWR) over manual `fetch` calls in `useEffect` where scalability matters.
            - Check that loading, error, and success states are handled clearly and predictably.

            ---

            ## ‚ö° Performance & Rendering
            - Look for preventable re-renders and suggest memoization (`React.memo`, `useCallback`, `useMemo`) where beneficial.
            - Review hook dependency arrays for correctness.
            - Ensure lists have stable keys ‚Äî avoid using array indices when a unique id exists.
            - Suggest virtualization only when list size or performance justifies it.
            - Encourage dynamic imports and code-splitting when components are large or rarely used.

            ---

            ## üß± Component Design & Architecture
            - Large, complex components should be considered for refactoring into smaller, focused ones.
            - Encourage extraction of reusable logic into **custom hooks** when it improves readability or testability.
            - Ensure component APIs are predictable, typed, and consistent.
            - Suggest decoupling tightly bound components where it improves flexibility or reusability.

            ---

            ## üß† TypeScript Quality
            - Minimize the use of `any` or overly broad types; justify them with comments when unavoidable.
            - Ensure props, state, and API responses are clearly and correctly typed.
            - Encourage using generics, utility types, and discriminated unions where they improve safety and clarity.
            - Review shared types for consistency and centralized organization.

            ---

            ## üß© Error Handling & Edge Cases
            - Ensure async operations use cleanup logic (`AbortController`, timeouts, unmount checks) where needed.
            - Verify meaningful error and loading states ‚Äî errors should guide recovery, not just say ‚ÄúSomething went wrong.‚Äù
            - Encourage proper error boundaries around critical UI.

            ---

            ## üß™ Testing & Reliability
            - Confirm tests validate **behavior** rather than implementation details.
            - Suggest additional tests for critical edge cases, async logic, or user interactions.
            - Encourage accessibility testing when UI components are complex or user-facing.

            ---

            ## ‚ôø Accessibility (A11y)
            - Encourage semantic HTML and accessible components.
            - Verify interactive elements are keyboard accessible.
            - Suggest proper use of ARIA attributes and focus management where applicable.
            - Note color contrast or reduced-motion concerns if visible.

            ---

            ## üé® Styling & Theming
            - Promote consistent use of styling approach (Tailwind, CSS Modules, styled-components, etc.).
            - Encourage responsive design and theming support (dark mode, accessibility preferences).
            - Discourage inline styles or overly specific CSS that hurts maintainability.

            ---

            ## üîí Security
            - Flag unsafe patterns like unsanitized `dangerouslySetInnerHTML`.
            - Ensure API calls and environment variables follow secure practices.
            - Encourage input validation and clear separation between server-only and client-side secrets.

            ---

            ## üöÄ Next.js Practices
            - Check that data fetching methods (`getServerSideProps`, `getStaticProps`, etc.) are used correctly.
            - Ensure API routes validate input and handle errors gracefully.
            - Suggest using `next/image` and metadata for SEO and performance.

            ---

            ## üß≠ Code Organization & Maintainability
            - Encourage feature-based folder structures and colocated tests.
            - Suggest removing dead code, duplication, or temporary debugging logic.
            - Emphasize clear naming and predictable file organization.
            - Recommend simplifying or documenting complex logic when it aids future maintenance.

            ---

            ‚úÖ Focus on **improving the codebase holistically**, not enforcing absolute rules.  
            ‚úÖ The best reviews balance **technical correctness**, **developer empathy**, and **contextual trade-offs**.

            Give me Markdown ONLY output with:
            - Summary
            - Issues (with severity)
            - Suggestions
            - Tests to add

            --- BEGIN DIFF ---
            ${{ steps.get_diff.outputs.diff }}
            --- END DIFF ---
          # we don't need tools for simple text review
          allowed_tools: ""
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}


      - name: Read Claude output
        id: read_claude
        run: |
          FILE="/home/runner/work/_temp/claude-execution-output.json"
          OUTFILE="claude_review.md"
          DEFAULT_MSG="Claude ran but didn't return a review. Check workflow logs."

          python - << 'PY'
          import json, os, pathlib

          file_path = "/home/runner/work/_temp/claude-execution-output.json"
          out_path = "claude_review.md"

          text = ""
          if os.path.exists(file_path):
              data = json.load(open(file_path, "r", encoding="utf-8"))
              # the action writes an array of events; the one we want has type == "result"
              if isinstance(data, list):
                  for item in data:
                      if isinstance(item, dict) and item.get("type") == "result":
                          text = item.get("result", "").strip()
              elif isinstance(data, dict) and data.get("type") == "result":
                  text = data.get("result", "").strip()

          if not text:
              raw = open(file_path, "r", encoding="utf-8").read()[:200]
              text = "Claude ran but didn't return a review.\n\nRaw snippet:\n```json\n" + raw + "\n```"

          pathlib.Path(out_path).write_text(text, encoding="utf-8")
          PY

          # now safely base64 it so we can pass via outputs
          REVIEW_B64=$(base64 -w 0 claude_review.md)
          echo "review_b64=${REVIEW_B64}" >> $GITHUB_OUTPUT


      - name: Post / update Claude review comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const marker = '<!-- claude-pr-review -->';
            const b64 = `${{ steps.read_claude.outputs.review_b64 }}`.trim();
            const review = Buffer.from(b64, 'base64').toString('utf8').trim();

            // 1- get existing comments
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            // 2- collapse any older Claude comments (optional)
            for (const c of comments) {
              if (c.body && c.body.includes(marker) && !c.body.startsWith('<details>')) {
                const formattedDate = new Date(c.created_at).toLocaleDateString('en-US', {
                  month: '2-digit',
                  day: '2-digit',
                  year: 'numeric'
                });
                const collapsed = `<details>\n<summary>Previous Claude review (${formattedDate})</summary>\n\n${c.body}\n</details>`;
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: c.id,
                  body: collapsed
                });
              }
            }

            // 3- see if we already have a "live" comment (after collapsing, we won't ‚Äî so just create)
            const body = `${marker}\n${review || "Claude ran but didn't return a review."}`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body
            });

